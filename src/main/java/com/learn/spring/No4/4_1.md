# 4.1 什么是面向切面编程
切面能使我们模块化横切关注点，例如安全，事务，日志等，如果要使用通用功能的话，最常见的技术是继承或委托，
但是如果在整个应用中都是用相同的基类，往往会导致一个脆弱的对象体系，而使用委托则可能需要对委托对象进行
复杂的调用。

## 4.1.1 定义AOP术语
描述切面的常用术语有通知，切点和连接点

### 4.1.1.1 通知（Advice）
**一个切面是有目标的，它要完成的工作就是通知。**  
通知定义了切面是什么，以及何时使用。除了描述切面要完成的工作，通知还解决了何时执行这个工作的问题。  
spring切面可以定义5种类型的通知：
 - 前置通知：在目标方法被调用之前调用通知功能；
 - 后置通知：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；
 - 返回通知：在目标方法成功执行之后调用通知；
 - 异常通知：在目标方法抛出异常后调用通知
 - 环绕通知：通知包裹了被通知的方法，在被通知方法调用前后执行自定义行为

### 4.1.1.2 连接点（Join point）
连接点是应用在执行过程中能够插入的实际的点，这个点可以是调用方法时，抛出异常时，甚至是修改一个字段时。切面
代码可以利用这些点插入到正常的流程之中，添加新的行为

### 4.1.1.3 切点（Pointcut）
如果说通知定义了切面的“什么”和“何时”的话，name切点就定义了“何处”。切点即连接点的部分抽象子集，描述了切面需要在
哪些连接点处切入。

### 4.1.1.4 切面（Aspect）
切面是通知和切点的结合。通知和切点共同定义了切面的全部内容--它是什么，在何时何处完成其功能。

### 4.1.1.5 织入（Weaving）
织入是把切面应用到目标对象并创建新的代理对象的过程。在目标对象的生命周期里，有多个店可以进行织入：
 
 - 编译器：切面在目标类编译时被织入。这种方式需要特殊的编译器，AspectJ的织入编译器就是以这种方式织入切面的。
 - 类加载器：切面在目标类呗加载到JVM中时被织入。这种方式需要特殊的类加载器，他可以在目标类被引入应用之前增强该目标类的字节码。  
 AspectJ5的加载时织入就支持以这种方式织入切面。
 - 运行期：切面在应用运行时的某和时刻被织入，一般情况下，在织入切面时，AOP容器会以目标对象动态的创建一个代理对象
 。spring AOP就是以这种方式织入切面的。
 
 ## 4.1.2 Spring 对AOP的支持
 并不是所有的AOP框架都是相同的，他们在连接点模型上可能有强弱之分。有些允许在字段修饰符级别应用通知，而另一些只支持与方法调用相关的
 连接点。他们织入的时机也有所不同，但是无论如何，创建切点来定义切面所织入的连接点是AOP框架的基本功能。  
 SpringAop在很多方面借鉴了AspectJ，Spring提供了4种类型的AOP支持：
 - 基于代理的经典Spring AOP
 - 纯POJO切面
 - @AspectJ注解驱动的切面
 - 注入式AspectJ切面（适用于Spring各版本）  
 
 前三种都是Spring AOP的变体，基于JDK动态代理，因此，Spring 对AOP的支持局限于方法拦截。  
 Spring经典AOP在现在看来已经非常复杂和笨重，所以不再介绍，只介绍简单的声明式AOP和基于注解的AOP。  
 借助Spring aop命名空间，我们可以将普通pojo转化为切面，实际上，这些pojo只是提供了满足切点条件时所需要调用的方法
 。遗憾的是，这种技术需要XML配置，但这的确是声明式地将对象转化为切面的简便方式。  
 Spring借鉴了AspectJ的切面，以提供注解驱动的AOP。本质上，它依然是Spring基于代理的AOP，但是编程模型
 几乎与成熟的AspectJ注解切面完全一致。这种AOP风格的好处在于能够不使用XML来实现功能。  
 如果你的AOP需求超过了简单的方法调用（如构造器或者属性拦截），name你需要考虑使用AspectJ来实现切面。这种情况下，上文所示的
 第四种类型能够帮助你将值注入到AspectJ驱动的切面中。  
 
 **Spring通知是Java编写的**  
 
 Spring所创建的通知都是使用标准的Java类编写的，对于我们开发来说比较熟悉。
 AspectJ则相反，它使用语言扩展方式来实现，这种方式有优点也有缺点。通过特有的AOP语言，我们可以获得更强大和细粒度的控制，以及更丰富的AOP
 工具集，但是我们需要额外学习工具和语法。
 
 **Spring在运行时通知对象**  
 
 通过在代理类包裹切面，Spring 在运行期把切面织入到Spring管理的bean中，知道应用需要被代理的bean时，
 Spring 才创建代理对象。如果使用的是ApplicationContext的话，在ApplicationContext从BeanFactory中加载所有bean
 的时候，Spring才会创建被代理的对象。
 
 **Spring只支持方法级别的连接点**  

方法拦截可以满足绝大部分的需求，如果修妖方法拦截之外的连接点拦截功能，我们可以用AspectJ来补充AOP的功能。


 